# 详细设计说明书

## 初步说明

本文档主要详细说明app模块的具体细节：

在概要设计说明书中，我们谈到MVP设计模式有着不少优点，但是同时它的缺点也是十分明显的：

1. 对视图的渲染全放在了Presenter中，所以View和Presenter之间的交互会过于频繁。
2. 同样一旦视图变更，Presenter也有可能变更。

这也就是说，View和Presenter之间的耦合度较高，两者之间需要解耦合，说到解耦合，我们通常想到抽象，再次思考这个问题，“视图变化引起逻辑变化”，视图变化通常由`xml`布局文件负责，逻辑变化也就是行为的变化，由此我们可以想到使用接口来实现View和Presenter之间的解耦合。

首先我们需要为View和Presenter分别生成一个接口，为了避免杂乱无章，我们将这两个接口声明在同一个文件中Contract；

在View接口中，声明与视图更新相关的方法，例如更新列表等操作。

在Presenter接口中，声明与业务逻辑相关的方法，例如发送请求获取列表等操作；

在这两个接口具体的实现类中，都分别持有对方的的接口实现类实例；

具体结构如下图：

![](http://cdn.nextto.top/amvp.bmp)

​                                                                      图 1.1 MVP解耦合实例

从上往下看，可以发现我们在Contract接口中，定义了View和Presenter接口；Presenter类实现了Contract.Presenter 接口，同时持有Contract.View接口；DecryptionFragment实现了Contract.View接口，同时持有Contract.Presenter接口。

由此整个操作过程，检测到用户输入，View调用Presenter中的方法，Presenter执行方法完成业务后，将调用View中的方法，完成视图的更新；

通过上述操作，我们成功将View和Presenter之间解耦合；

## 进一步说明

### View进行列表数据更新

![](http://cdn.nextto.top/adapter.bmp)

​                                                                    图 1.2 Adapter MVP

可以看到较上图，本图多了两个类`BaseFragemnt`和`Adapter`，这两个类是完全为了View而存在，BaseFragment提供了View的本质，提供了许多必要的方法。Adapter是为视图中的列表而存在的适配器。适配器数据的更新一般在Contract.View的接口方法中。

### 文件读取/写入

在概要设计中我们要达成的目标中有这样两条：

1. 能从普通文件中读取多行文本，加密后再写入到文件中；
2. 能从Excel文件中批量读取明文，加密后再写入到Excel文件中；

看似有所不同，实际上这两者是一致的。只是一个是普通文本文件，一个是Excel文件罢了；

这样是可以根据行为抽象出一个接口的，具体如下：

![](http://cdn.nextto.top/FileImpl.bmp)

接口中定义了readFile(ArrayList<EncryptionBean> list, String filePath)和writeFile(ArrayList<EncryptionBean> list, String filePath)两个方法。

其中第一个read方法稍稍违反了不应改变传参的准则，但是无伤大雅。readFile方法根据文件路径，将数据加载到传参List<Encryption>中。

第二个write方法根据文件路径和传参List<Encryption>，将数据保存到文件中。

CommonFile和ExcelFile这两个类，针对不同文件提供了不同的实现方式。

### 各界面的跳转

由于创建Activity需要的资源较多，所以本应用程序只有一个Activity，其他所有的界面显示全部使用Fragment；

![](http://cdn.nextto.top/activity.bmp)

我们为这个唯一的FunctionActivity定义了一个父类，声明了一些通用方法，用于显示进度条和消息，为之后的需求做准备。

FunctionActivity的布局文件使用了DrawerLayout布局，界面主体使用一个占满屏幕的FrameLayout，用于界面的跳转；抽屉弹出的菜单项点击事件如下：

```java
private void DrawerItemClick(String title) {
    // todo international
    switch (title) {
      case "加密":
        replaceFragment(EncryptionFragment.getInstance());
        break;
      case "解密":
        replaceFragment(DecryptionFragment.getInstance());
        break;
      case "加密/解密":
        replaceFragment(EncryptionDecryptionFragment.getInstance());
        break;
      case "文件加密/解密":
        replaceFragment(FileEncryptionDecryptionFragment.getInstance());
        break;
      default:
        break;
    }
  }
```

每一个继承BaseFragment的子类都会提供一个静态方法，来提供实例；

界面切换执行的代码如下：

```java
private void replaceFragment(Fragment fragment) {
    FragmentManager fragmentManager = getSupportFragmentManager();
    FragmentTransaction transaction = fragmentManager.beginTransaction();
    transaction.setCustomAnimations(android.R.anim.fade_in, android.R.anim.fade_out);
    transaction.replace(R.id.function_interface, fragment);
    transaction.commit();
    closeDrawer();
  }
```

切换过程，添加了淡入淡出的视觉效果；

### 界面优化

对于界面的优化，我定义了一个AppTheme的style，定义了包括但不限于默认颜色、字体大小等设置。

```xml
<style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar">
    <item name="colorPrimary">@color/paleGrey</item>
    <item name="toolbarStyle">@style/AppTheme.Toolbar</item>
    <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
    <item name="android:windowBackground">@color/paleGrey</item>
    <item name="colorAccent">@color/colorAccent</item>
    <item name="android:textColor">@color/text_color_grey</item>
    <item name="android:textSize">@dimen/text_size</item>
    <item name="android:textColorHint">@color/blueyGrey</item>
    <item name="windowActionModeOverlay">true</item>
    <item name="android:windowIsTranslucent">false</item>
    <item name="android:statusBarColor">@color/colorPrimary</item>
  </style>
```

与此同时，我还为常用的按钮定义了样式：

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">

  <item>
    <shape android:shape="rectangle">
      <corners android:radius="20dp"/>
      <gradient android:endColor="@color/lightPrimary" android:startColor="@color/colorPrimary"/>
    </shape>
  </item>
</selector>
```

